// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_rpc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRpcRequestImpl();
void InitDefaultsRpcRequest();
void InitDefaultsRpcResponseImpl();
void InitDefaultsRpcResponse();
inline void InitDefaults() {
  InitDefaultsRpcRequest();
  InitDefaultsRpcResponse();
}
}  // namespace protobuf_rpc_2eproto
namespace rpc {
class RpcRequest;
class RpcRequestDefaultTypeInternal;
extern RpcRequestDefaultTypeInternal _RpcRequest_default_instance_;
class RpcResponse;
class RpcResponseDefaultTypeInternal;
extern RpcResponseDefaultTypeInternal _RpcResponse_default_instance_;
}  // namespace rpc
namespace rpc {

// ===================================================================

class RpcRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.RpcRequest) */ {
 public:
  RpcRequest();
  virtual ~RpcRequest();

  RpcRequest(const RpcRequest& from);

  inline RpcRequest& operator=(const RpcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcRequest(RpcRequest&& from) noexcept
    : RpcRequest() {
    *this = ::std::move(from);
  }

  inline RpcRequest& operator=(RpcRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcRequest* internal_default_instance() {
    return reinterpret_cast<const RpcRequest*>(
               &_RpcRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RpcRequest* other);
  friend void swap(RpcRequest& a, RpcRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RpcRequest& from);
  void MergeFrom(const RpcRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service = 1;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  #if LANG_CXX11
  void set_service(::std::string&& value);
  #endif
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // required string method = 2;
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 2;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // required bytes argument_bytes = 3;
  bool has_argument_bytes() const;
  void clear_argument_bytes();
  static const int kArgumentBytesFieldNumber = 3;
  const ::std::string& argument_bytes() const;
  void set_argument_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_argument_bytes(::std::string&& value);
  #endif
  void set_argument_bytes(const char* value);
  void set_argument_bytes(const void* value, size_t size);
  ::std::string* mutable_argument_bytes();
  ::std::string* release_argument_bytes();
  void set_allocated_argument_bytes(::std::string* argument_bytes);

  // @@protoc_insertion_point(class_scope:rpc.RpcRequest)
 private:
  void set_has_service();
  void clear_has_service();
  void set_has_method();
  void clear_has_method();
  void set_has_argument_bytes();
  void clear_has_argument_bytes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr argument_bytes_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsRpcRequestImpl();
};
// -------------------------------------------------------------------

class RpcResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpc.RpcResponse) */ {
 public:
  RpcResponse();
  virtual ~RpcResponse();

  RpcResponse(const RpcResponse& from);

  inline RpcResponse& operator=(const RpcResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcResponse(RpcResponse&& from) noexcept
    : RpcResponse() {
    *this = ::std::move(from);
  }

  inline RpcResponse& operator=(RpcResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcResponse* internal_default_instance() {
    return reinterpret_cast<const RpcResponse*>(
               &_RpcResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RpcResponse* other);
  friend void swap(RpcResponse& a, RpcResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RpcResponse& from);
  void MergeFrom(const RpcResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RpcResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes response_message = 1;
  bool has_response_message() const;
  void clear_response_message();
  static const int kResponseMessageFieldNumber = 1;
  const ::std::string& response_message() const;
  void set_response_message(const ::std::string& value);
  #if LANG_CXX11
  void set_response_message(::std::string&& value);
  #endif
  void set_response_message(const char* value);
  void set_response_message(const void* value, size_t size);
  ::std::string* mutable_response_message();
  ::std::string* release_response_message();
  void set_allocated_response_message(::std::string* response_message);

  // @@protoc_insertion_point(class_scope:rpc.RpcResponse)
 private:
  void set_has_response_message();
  void clear_has_response_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr response_message_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsRpcResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RpcRequest

// required string service = 1;
inline bool RpcRequest::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcRequest::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcRequest::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcRequest::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service();
}
inline const ::std::string& RpcRequest::service() const {
  // @@protoc_insertion_point(field_get:rpc.RpcRequest.service)
  return service_.GetNoArena();
}
inline void RpcRequest::set_service(const ::std::string& value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.RpcRequest.service)
}
#if LANG_CXX11
inline void RpcRequest::set_service(::std::string&& value) {
  set_has_service();
  service_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.RpcRequest.service)
}
#endif
inline void RpcRequest::set_service(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.RpcRequest.service)
}
inline void RpcRequest::set_service(const char* value, size_t size) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.RpcRequest.service)
}
inline ::std::string* RpcRequest::mutable_service() {
  set_has_service();
  // @@protoc_insertion_point(field_mutable:rpc.RpcRequest.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequest::release_service() {
  // @@protoc_insertion_point(field_release:rpc.RpcRequest.service)
  clear_has_service();
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequest::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    set_has_service();
  } else {
    clear_has_service();
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:rpc.RpcRequest.service)
}

// required string method = 2;
inline bool RpcRequest::has_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcRequest::set_has_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcRequest::clear_has_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_method();
}
inline const ::std::string& RpcRequest::method() const {
  // @@protoc_insertion_point(field_get:rpc.RpcRequest.method)
  return method_.GetNoArena();
}
inline void RpcRequest::set_method(const ::std::string& value) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.RpcRequest.method)
}
#if LANG_CXX11
inline void RpcRequest::set_method(::std::string&& value) {
  set_has_method();
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.RpcRequest.method)
}
#endif
inline void RpcRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.RpcRequest.method)
}
inline void RpcRequest::set_method(const char* value, size_t size) {
  set_has_method();
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.RpcRequest.method)
}
inline ::std::string* RpcRequest::mutable_method() {
  set_has_method();
  // @@protoc_insertion_point(field_mutable:rpc.RpcRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequest::release_method() {
  // @@protoc_insertion_point(field_release:rpc.RpcRequest.method)
  clear_has_method();
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequest::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    set_has_method();
  } else {
    clear_has_method();
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:rpc.RpcRequest.method)
}

// required bytes argument_bytes = 3;
inline bool RpcRequest::has_argument_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcRequest::set_has_argument_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcRequest::clear_has_argument_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcRequest::clear_argument_bytes() {
  argument_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_argument_bytes();
}
inline const ::std::string& RpcRequest::argument_bytes() const {
  // @@protoc_insertion_point(field_get:rpc.RpcRequest.argument_bytes)
  return argument_bytes_.GetNoArena();
}
inline void RpcRequest::set_argument_bytes(const ::std::string& value) {
  set_has_argument_bytes();
  argument_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.RpcRequest.argument_bytes)
}
#if LANG_CXX11
inline void RpcRequest::set_argument_bytes(::std::string&& value) {
  set_has_argument_bytes();
  argument_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.RpcRequest.argument_bytes)
}
#endif
inline void RpcRequest::set_argument_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_argument_bytes();
  argument_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.RpcRequest.argument_bytes)
}
inline void RpcRequest::set_argument_bytes(const void* value, size_t size) {
  set_has_argument_bytes();
  argument_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.RpcRequest.argument_bytes)
}
inline ::std::string* RpcRequest::mutable_argument_bytes() {
  set_has_argument_bytes();
  // @@protoc_insertion_point(field_mutable:rpc.RpcRequest.argument_bytes)
  return argument_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequest::release_argument_bytes() {
  // @@protoc_insertion_point(field_release:rpc.RpcRequest.argument_bytes)
  clear_has_argument_bytes();
  return argument_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequest::set_allocated_argument_bytes(::std::string* argument_bytes) {
  if (argument_bytes != NULL) {
    set_has_argument_bytes();
  } else {
    clear_has_argument_bytes();
  }
  argument_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), argument_bytes);
  // @@protoc_insertion_point(field_set_allocated:rpc.RpcRequest.argument_bytes)
}

// -------------------------------------------------------------------

// RpcResponse

// required bytes response_message = 1;
inline bool RpcResponse::has_response_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcResponse::set_has_response_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcResponse::clear_has_response_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcResponse::clear_response_message() {
  response_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_response_message();
}
inline const ::std::string& RpcResponse::response_message() const {
  // @@protoc_insertion_point(field_get:rpc.RpcResponse.response_message)
  return response_message_.GetNoArena();
}
inline void RpcResponse::set_response_message(const ::std::string& value) {
  set_has_response_message();
  response_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpc.RpcResponse.response_message)
}
#if LANG_CXX11
inline void RpcResponse::set_response_message(::std::string&& value) {
  set_has_response_message();
  response_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpc.RpcResponse.response_message)
}
#endif
inline void RpcResponse::set_response_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_response_message();
  response_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpc.RpcResponse.response_message)
}
inline void RpcResponse::set_response_message(const void* value, size_t size) {
  set_has_response_message();
  response_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpc.RpcResponse.response_message)
}
inline ::std::string* RpcResponse::mutable_response_message() {
  set_has_response_message();
  // @@protoc_insertion_point(field_mutable:rpc.RpcResponse.response_message)
  return response_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponse::release_response_message() {
  // @@protoc_insertion_point(field_release:rpc.RpcResponse.response_message)
  clear_has_response_message();
  return response_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponse::set_allocated_response_message(::std::string* response_message) {
  if (response_message != NULL) {
    set_has_response_message();
  } else {
    clear_has_response_message();
  }
  response_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_message);
  // @@protoc_insertion_point(field_set_allocated:rpc.RpcResponse.response_message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
